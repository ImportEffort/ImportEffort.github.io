<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="说道做到，这就是我的忍道">
<meta property="og:type" content="website">
<meta property="og:title" content="ImportEffort的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="ImportEffort的博客">
<meta property="og:description" content="说道做到，这就是我的忍道">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ImportEffort的博客">
<meta name="twitter:description" content="说道做到，这就是我的忍道">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> ImportEffort的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ImportEffort的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/06/关于LayoutInflate和View-infalte的参数意义以及区别总结/" itemprop="url">
                  关于LayoutInflate和View.infalte的参数意义以及区别总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-06T00:11:56+08:00" content="2016-09-06">
              2016-09-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="关于LayoutInflate和View-infalte的参数意义以及区别总结"><a href="#关于LayoutInflate和View-infalte的参数意义以及区别总结" class="headerlink" title="关于LayoutInflate和View.infalte的参数意义以及区别总结"></a>关于LayoutInflate和View.infalte的参数意义以及区别总结</h2><p>首先感谢AndroidDevelopment邪教群中月亮和六便士的讲解。接下来让我们步入正题：</p>
<h3 id="Android中填充布局的两种方式"><a href="#Android中填充布局的两种方式" class="headerlink" title="Android中填充布局的两种方式"></a>Android中填充布局的两种方式</h3><p>Android中用来填充布局的主要的两个方法如下：</p>
<ol>
<li><code>LayoutInflater.from(getContext()).inflate(resource, root, attachToRoot);</code></li>
<li><code>View.inflate(context, resource, root);</code></li>
</ol>
<p>根据个人习惯不同，可能大家使用方法不同，之前我是习惯使用 <code>View.inflate(getContext(),R.layout.layout_main,null);</code>方法的，直到有一天我遇到一个问题：</p>
<p> 我发现使用该方法，为listView（RecycleView）填充item条目的时候，根布局设置的layout参数总是不起作用，后来了解，在这种情况下，其实根布局的所有的属性都是不管用的。</p>
<p>今天下午在邪教群 月亮和六便士 讲解里我了解了其中的原因：</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/09/06/关于LayoutInflate和View-infalte的参数意义以及区别总结/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/25/Android-6-0新特性/" itemprop="url">
                  Android 6.0新特性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-25T01:11:45+08:00" content="2016-08-25">
              2016-08-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="6-0新特性"><a href="#6-0新特性" class="headerlink" title="6.0新特性"></a>6.0新特性</h2><h3 id="TextInputLayout的使用"><a href="#TextInputLayout的使用" class="headerlink" title="TextInputLayout的使用"></a>TextInputLayout的使用</h3><p>高级炫酷带有提示的输入框，相当于输入框中的战斗框<br>使用需要依赖design类库：</p>
<p>  <code>compile &#39;com.android.support:design:23.0.0+&#39;</code></p>
<p>使用步骤：</p>
<ul>
<li><p>在布局文件中使用TextInputLayout并再其内部包裹一个EditText</p>
<pre><code>&lt;android.support.design.widget.TextInputLayout
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;&gt;

    &lt;EditText
        android:id=&quot;@+id/et_name&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:hint=&quot;请输入姓名&quot; /&gt;
&lt;/android.support.design.widget.TextInputLayout&gt;
</code></pre></li>
<li><p>editText.setError(“输入错误提示信息”);</p>
<pre><code>String name = etName.getText().toString().trim();

if (name.length() &gt; 3) {
   etName.setError(&quot;用户名不得超过3个字符&quot;);
}
</code></pre></li>
<li><p>效果图见下方</p>
</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/08/25/Android-6-0新特性/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/21/Android中的动画-ValueAnimator值动画的使用/" itemprop="url">
                  Android中的动画---ValueAnimator值动画的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-21T08:49:59+08:00" content="2016-08-21">
              2016-08-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>##Android中动画简单分类</p>
<p>Android包含三种动画：View Animation、 Drawable Animation、Property Animation（Android3.0新引入）。</p>
<h3 id="View-Animation（view动画）："><a href="#View-Animation（view动画）：" class="headerlink" title="View Animation（view动画）："></a>View Animation（view动画）：</h3><p>view动画是一个比较旧的动画系统，并且它仅能用于View对象。主要的类别有： AlphaAnimation透明度动画, AnimationSet动画集合, RotateAnimation缩放动画, ScaleAnimation旋转动画, TranslateAnimation平移动画<br>基于View的渐变动画，只改变了View的绘制效果，而实际属性值未变。比如动画移动一个按钮位置，但按钮点击的实际位置仍未改变。在代码中定义动画，可以参考AnimationSet类和Animation的子类；而如果使用XML，可以在res/anim/文件夹中定义XML文件。这个动画系统相对与容易创建，并且对于应用程序中所遇到的大多数需求提供了足够的能力。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/08/21/Android中的动画-ValueAnimator值动画的使用/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/20/线程池的使用-自定义多线程下载/" itemprop="url">
                  线程池的使用---自定义多线程下载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-20T12:34:29+08:00" content="2016-08-20">
              2016-08-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文主要介绍了Android中线程池，以及自定义ThreadPoolManger的例子。老司机可以绕道。</p>
<p>##Android线程池使用</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li>线程池的作用：<ol>
<li>线程池作用就是限制系统中执行线程的数量。<br>根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。</li>
</ol>
</li>
<li><p>为什么要用线程池:</p>
<ol>
<li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。这里的意思是我们不用手动new多个Thread，只需要往线程池中放入Runnable对象就好。</li>
<li>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li>
</ol>
</li>
</ul>
<p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。而本文中使用的ThreadPoolExecutor<br>即为ExecutorService的默认实现。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/08/20/线程池的使用-自定义多线程下载/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/13/UniversalImageLoader的初体验/" itemprop="url">
                  UniversalImageLoader的初体验
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-13T14:39:40+08:00" content="2016-08-13">
              2016-08-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>GitHub 图片加载开源项目库：UniversalImageLoader<br>项目地址<a href="：https://github.com/nostra13/Android-Universal-Image-Loader">：https://github.com/nostra13/Android-Universal-Image-Loader</a></p>
</blockquote>
<p>GitHub 项目主页描述的，UniversalImageLoader具有的特性：</p>
<ul>
<li><p>Multithread image loading (async or sync) 支持多线程 同步和异步加载 </p>
</li>
<li><p>Wide customization of ImageLoader’s configuration (thread executors, downloader, decoder, memory and disk cache, display image options, etc.) 支持对图片加载过程的多种配置，包括线程池的大小，解码，内存和本地缓存，图片显示选项的配置。</p>
</li>
<li><p>Many customization options for every display image call (stub images, caching<br>switch, decoding options, Bitmap processing and displaying, etc.) 对每个加载图片的的单独配置。</p>
</li>
<li><p>Image caching in memory and/or on disk (device’s file system or SD card) 图片的缓存位置</p>
</li>
<li><p>Listening loading process (including downloading progress) 监听图片加载过程，包括图片下载过程</p>
</li>
</ul>
<hr>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/08/13/UniversalImageLoader的初体验/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/13/打造万能ListView的ViewHolder和Adapter/" itemprop="url">
                  打造万能ListView的ViewHolder和Adapter
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-13T13:08:21+08:00" content="2016-08-13">
              2016-08-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="BaseHolder的抽取："><a href="#BaseHolder的抽取：" class="headerlink" title="BaseHolder的抽取："></a>BaseHolder的抽取：</h2><blockquote>
<p>抽取基类： 程序的多个地方用到大量重复的代码，这时候我们抽取基类，子类只需要关注必须实现的方法，来提高代码的编写效率，减少冗余代码。</p>
</blockquote>
<h3 id="listView的Adapter常规写法："><a href="#listView的Adapter常规写法：" class="headerlink" title="listView的Adapter常规写法："></a>listView的Adapter常规写法：</h3><p>正常的listview的适配器Adapter的getView和ViewHolder的使用方法：</p>
<pre><code>public View getView(int position, View convertView, ViewGroup parent) {
    ViewHolder viewHolder = null;
    if (convertView == null) {
        //1. 获取布局文件的view对象
        convertView = View.inflate(GooglePalyApplication.context,
            R.layout.home_list_item, null);
        //2. 初始化viewholder
        viewHolder = new ViewHolder();
        //3. 为viewHolder的变量赋值，通过findViewbyId 
        viewHolder.tv = (TextView) convertView.findViewById(R.id.tv);
        //4. 为布局文件对象设置tag 以提高findViewbyId的效率
        convertView.setTag(viewHolder);
    }else{
        viewHolder = (ViewHolder) convertView.getTag();
    }
    //5. 初始化数据
    AppInfo appInfo = list.get(postion);
    viewHolder.tv.setText(appInfo.name);
    return convertView;
}

class ViewHolder{
    TextView tv;
}
</code></pre><p>对getView执行的动作进行简单的分析我们可以发现，他做了如下几件事：</p>
<ol>
<li>获取布局文件的view对象</li>
<li>初始化viewholder</li>
<li>为viewHolder的变量赋值，通过findViewbyId </li>
<li>为布局文件对象设置tag 以提高findViewbyId的效率</li>
<li>初始化数据</li>
</ol>
<p>可以看出以上所有的步骤都与ViewHolder有关，这里我们要实现的就是将这些步骤放在ViewHolder内部完成，简化getView内部实现。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/08/13/打造万能ListView的ViewHolder和Adapter/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/29/自定义控件之自定View实现开关（ToggleButton）效果/" itemprop="url">
                  自定义控件之自定View实现开关（ToggleButton）效果
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-29T22:48:42+08:00" content="2016-07-29">
              2016-07-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>##自定控件简介：</p>
<p>　　Android系统本身没有自带实现像，IOS那种ToggleButton的效果API。但需求往往是IOS和Android两个平台的产品UI效果要尽可能统一。我们经常见到手机系统中，数据流量开关功能的UI就是进行了这样的自定义。</p>
<p>　　要使用自定义控件，我们往往需要进行自定义一个类继承，View或者ViewGroup，让后进行自己需要功能的添加。但是如何能把自己定义的控件成功展示出想要的效果，就需要了解系统View的绘制过程了：简单来说一个view从XML布局文件展示到界面上都需要经过三个阶段：测量阶段（onMeasure  ）,          布局(onLayout),画控件(onDraw)；</p>
<ol>
<li><p>onMeasure()方法，该方法实现的功能如下：    </p>
<ol>
<li>设置本View视图的最终大小，该功能的实现通过调用setMeasuredDimension()方法去设置实际的高(对应属性mMeasuredHeight)和宽(对应属性：mMeasureWidth)；</li>
<li>如果该View对象是个ViewGroup类型，需要重写该onMeasure()方法，对其子视图进行遍历的measure()过程。我们需要该方法内部调用子view本身的measure方法来确定，每个子view控件的大小。</li>
</ol>
</li>
<li><p>layout布局过程：</p>
<ol>
<li>主要作用 ：为将整个根据子视图的大小以及布局参数将View树放到合适的位置上。</li>
<li>如果我们要实现的是一个View如本例中的ToggleButton而本身不包含子控件，那么我们不需要手动去实现这个方法。</li>
</ol>
</li>
<li><p>onDraw绘制过程：</p>
<ol>
<li>主要作用就是初始view的视图，并和 invalidate（）组合来实现控件的动态绘制（移动控件的位置）；</li>
<li>另外如果我们的自定义控件继承自ViewGroup那么我们就可以省略这个过程，因为系统的dispatchDraw()方法内部会遍历每个子视图，调用drawChild()去重新回调每个子视图的draw()方法。</li>
</ol>
</li>
<li><p>invalidate() 重新绘制</p>
<ol>
<li>从该方法实现的功能来看很类与ListView的notifyDatehasChanged方法，功能就是当我改变View或者子View的内容的时候，调用这个方法就会为我们重画当前当前的View</li>
<li>官方解释的话大概是下面这个意思：invalidate();使整个View无效化, 如果当前的View可见，那么会在未来的某一时刻调用onDraw invalidate()只能在主线程调用 如果想在子线程刷新界面 那么需要调用postInvalidate();</li>
</ol>
</li>
</ol>
<hr>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/07/29/自定义控件之自定View实现开关（ToggleButton）效果/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/29/Application捕获全局异常/" itemprop="url">
                  Application捕获全局异常
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-29T00:57:01+08:00" content="2016-07-29">
              2016-07-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##自定义全局Appliction<br>　　我们都知道我们的可以自定义四大组件，并且在配置文件中声明并使用，其实Application也可以。而且定义一个全局的Appliction其内部的方法，参数等生命周期都是整个应用的生命周期。也就是只有用户退出应用了，才会被回收。所以这里非常适合定义一些全局使用的方法或者常量。</p>
<ol>
<li><p>在配置文件中使用自定义的Applcation：</p>
<pre><code> &lt;application
        android:name=&quot;.MyApplication&quot;
        ······&gt;
    ·····
    ·····
&lt;/application&gt;
</code></pre></li>
<li><p>自定义一个类继承自Application：</p>
<pre><code>public class MobileSafeApplication extends Application {

    @Override
    public void onCreate() {
        super.onCreate();

        // 设置未捕获异常处理器
        Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
    }

    class MyUncaughtExceptionHandler implements UncaughtExceptionHandler {

        // 未捕获的异常都会走到此方法中
        // Throwable是Exception和Error的父类
        @Override
        public void uncaughtException(Thread thread, Throwable ex) {
            System.out.println(&quot;产生了一个未处理的异常, 但是被哥捕获了...&quot;);
            // 将异常日志输入到本地文件中, 找机会上传到服务器,供技术人员分析
            File file = new File(Environment.getExternalStorageDirectory(),
                    &quot;error.log&quot;);
            try {
                PrintWriter writer = new PrintWriter(file);
                ex.printStackTrace(writer);
                writer.close();
            } catch (Exception e) {
                e.printStackTrace();
            }

            // 结束当前进程
            android.os.Process.killProcess(android.os.Process.myPid());
        }
    }
}
</code></pre></li>
<li><p>捕获全局异常，一般我们的应用程序异常都在使用的时候捕获，但是总有一些奇怪的异常，出现概率非常小，比如一个功能使用几百次，只有一次崩溃了。这种问题很难进行预测处理，这时候我们就需要使用全局异常来捕获了：</p>
<pre><code>// 设置未捕获异常处理器
Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
</code></pre></li>
<li><p>捕获异常我们都会上传到服务器，但是这种异常很特殊，很可能发生异常程序就崩溃退出了，所以良好的做法是先保存到本地，然后带用户下次使用的时候，偷偷上传服务器。</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/28/为你的应用添加守护进程，实现应用页面跳转/" itemprop="url">
                  为你的应用添加守护进程，实现应用页面跳转
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-28T19:30:49+08:00" content="2016-07-28">
              2016-07-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前台服务（守护进程）"><a href="#前台服务（守护进程）" class="headerlink" title="前台服务（守护进程）"></a>前台服务（守护进程）</h2><ul>
<li>360, 金山, 腾讯的应用是杀不死的, 这时因为他们开启了前台服务, 系统认为他们是前台进程.而我们点击，清理内存控件的时候， ActivityManager.killBackgroundProcesses只能杀死后台进程. </li>
<li>要让一个应用成为前台进程, 可以在使用前台服务. 前台服务也叫守护服务, 会在通知栏里显示一个通知, 通知栏所在的应用叫 SystemUI, 这个应用是不会挂掉的, 如果一个应用有前台服务, 在通知栏里有通知,系统也会认为这个进程是前台进程, 不会杀死它.</li>
</ul>
<p>实现方法：</p>
<ol>
<li>守护进程服务，通过服务来实现的。效果是在我们通知栏添加了一条不会消失的Notification。</li>
<li><p>我们在应用开启的时候，就开启守护进程服务。</p>
<pre><code>public class ProtectService extends Service {

    @Override
    public IBinder onBind(Intent intent) {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public void onCreate() {
        super.onCreate();

        // 参1 通知的id
        Notification notification = new Notification();
        notification.icon = R.drawable.ic_launcher;
        // 远程view
        notification.contentView = new RemoteViews(getPackageName(),
                R.layout.notify_view);

        Intent intent = new Intent();
        intent.setAction(&quot;android.intent.action.MAIN&quot;);
        intent.addCategory(&quot;android.intent.category.LAUNCHER&quot;);
        ComponentName componentName = new ComponentName(
                getApplicationContext(), SpalshActivity.class);
        intent.setComponent(componentName);

        // 延时意图 打开一个activity
        PendingIntent pendingIntent = PendingIntent.getActivity(
                getApplicationContext(), 100011, intent,
                PendingIntent.FLAG_UPDATE_CURRENT);
        notification.contentView.setOnClickPendingIntent(R.id.notity_root,
                pendingIntent);

        // 让服务成为前台进程 不会轻易被杀掉
        startForeground(1000, notification);
    }
}
</code></pre></li>
</ol>
<p>留意这几行代码：我们为我们的跳转intent添加了一个组件名称对象。这样以来，系统就可以帮我们判断，当前应用是否在后台运行。如果在后台运行，那么就跳转到当前运行的界面。如果没有运行则帮我们找到该应用的Launch页面，即打开该应用。实际上应用的快捷方式也是应用了这个跳转方法。</p>
<pre><code>Intent intent = new Intent();
intent.setAction(&quot;android.intent.action.MAIN&quot;);
intent.addCategory(&quot;android.intent.category.LAUNCHER&quot;);
ComponentName componentName = new ComponentName(
getApplicationContext(), SpalshActivity.class);
intent.setComponent(componentName);
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/28/ViewPager简单使用-实现广告轮播/" itemprop="url">
                  ViewPager简单使用--实现广告轮播
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-28T12:20:15+08:00" content="2016-07-28">
              2016-07-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="ViewPager实现广告轮播"><a href="#ViewPager实现广告轮播" class="headerlink" title="ViewPager实现广告轮播"></a>ViewPager实现广告轮播</h1><h2 id="官方support包的作用"><a href="#官方support包的作用" class="headerlink" title="官方support包的作用"></a>官方support包的作用</h2><h3 id="1-v4，v7，v13包都是干什么用的？"><a href="#1-v4，v7，v13包都是干什么用的？" class="headerlink" title="1.v4，v7，v13包都是干什么用的？"></a>1.v4，v7，v13包都是干什么用的？</h3><ol>
<li>support包是android发布的支持库；提供给老版本使用新版本的功能。</li>
<li>v4 – 最低android为API1.6的手及以上提供新版本的功能 </li>
<li>v7 – 最低Android为API2.1手机及以上提供新版本的功能，注意，v7是要依赖v4这个包的，如果需要使用v7，两个包必须被同时加入工程</li>
<li>v13– 这个包我们用的就比较少了,一般在开发平板应用的时候才会用到。</li>
<li><strong>ViewPager在Android-support-V4包中</strong>。</li>
</ol>
<p>###2.如何关联v4的源码</p>
<ol>
<li>libs新建一个file名字为v4包名adnroid-suport-v4.jar.properties,</li>
<li>在该文件中添加一行src=D:\eclipse\eclipseForAndorid_18\sdk\extras\android\support\v4\src （没有分号），即为sdk中v4包中src的全路径。</li>
<li>关闭当前工程（closeProject），再次打开工程就可以看到源码了。</li>
<li>导入源码后我们在eclipse中就可以看到对应viewpager的方法参数了，而不是arg0.1.2···之类的了。</li>
</ol>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/07/28/ViewPager简单使用-实现广告轮播/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="ImportEffort" />
          <p class="site-author-name" itemprop="name">ImportEffort</p>
          <p class="site-description motion-element" itemprop="description">说道做到，这就是我的忍道</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ImportEffort</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
