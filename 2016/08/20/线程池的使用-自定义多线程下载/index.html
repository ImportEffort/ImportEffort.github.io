<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="android笔记," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="简介本文主要介绍了Android中线程池，以及自定义ThreadPoolManger的例子。老司机可以绕道。
##Android线程池使用
线程池
线程池的作用：
线程池作用就是限制系统中执行线程的数量。根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排队等候。一个任务执行完毕，再从队列的中取最前面的任">
<meta property="og:type" content="article">
<meta property="og:title" content="线程池的使用---自定义多线程下载">
<meta property="og:url" content="http://yoursite.com/2016/08/20/线程池的使用-自定义多线程下载/index.html">
<meta property="og:site_name" content="ImportEffort的博客">
<meta property="og:description" content="简介本文主要介绍了Android中线程池，以及自定义ThreadPoolManger的例子。老司机可以绕道。
##Android线程池使用
线程池
线程池的作用：
线程池作用就是限制系统中执行线程的数量。根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排队等候。一个任务执行完毕，再从队列的中取最前面的任">
<meta property="og:image" content="https://ooo.0o0.ooo/2016/08/21/57b9df462f6a8.png">
<meta property="og:updated_time" content="2016-08-21T17:16:39.408Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="线程池的使用---自定义多线程下载">
<meta name="twitter:description" content="简介本文主要介绍了Android中线程池，以及自定义ThreadPoolManger的例子。老司机可以绕道。
##Android线程池使用
线程池
线程池的作用：
线程池作用就是限制系统中执行线程的数量。根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排队等候。一个任务执行完毕，再从队列的中取最前面的任">
<meta name="twitter:image" content="https://ooo.0o0.ooo/2016/08/21/57b9df462f6a8.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/08/20/线程池的使用-自定义多线程下载/"/>

  <title> 线程池的使用---自定义多线程下载 | ImportEffort的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ImportEffort的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                线程池的使用---自定义多线程下载
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-20T12:34:29+08:00" content="2016-08-20">
              2016-08-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文主要介绍了Android中线程池，以及自定义ThreadPoolManger的例子。老司机可以绕道。</p>
<p>##Android线程池使用</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li>线程池的作用：<ol>
<li>线程池作用就是限制系统中执行线程的数量。<br>根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。</li>
</ol>
</li>
<li><p>为什么要用线程池:</p>
<ol>
<li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。这里的意思是我们不用手动new多个Thread，只需要往线程池中放入Runnable对象就好。</li>
<li>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li>
</ol>
</li>
</ul>
<p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。而本文中使用的ThreadPoolExecutor<br>即为ExecutorService的默认实现。</p>
<a id="more"></a>
<h3 id="如何创建一个ThreadPoolExecutor"><a href="#如何创建一个ThreadPoolExecutor" class="headerlink" title="如何创建一个ThreadPoolExecutor"></a>如何创建一个ThreadPoolExecutor</h3><p>ThreadPoolExecutor是ExecutorServeice的实现类： 我们采用构造方法参数最多的一个方法来创建对象，其他的构造方法省略的参数只是采用了默认的参数而已。</p>
<p><code>ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);</code></p>
<ol>
<li>corePoolSize：核心线程池数量 线程池中所能同时执行的任务数量；</li>
<li>maximumPoolSize： 最大线程池数量，超出缓冲队列的任务会放入最大线程池中等待，注意：maximumPoolSize是包含了corePoolSize的；</li>
<li>keepAliveTime： 存活时间，表示的是最大线程池中等待任务的存活时间；</li>
<li>unit： keepAliveTime参数的单位，时分秒等；</li>
<li><p>workQueue：//缓冲队列，会将超出corePoolSize的任务放入workQueue等待着。</p>
<pre><code>BlockingQueue&lt;Runnable&gt; workQueue = new LinkedBlockingQueue&lt;Runnable&gt;(Integer.MAX_VALUE); 这种创建方式和不传入参数是相同的。
</code></pre></li>
<li><p>threadFactory： 创建线程使用的工厂类，我们一般使用其静态方法创建一个默认的线程工厂，来创建线程对象。</p>
<pre><code>Executors.defaultThreadFactory(),     
</code></pre></li>
<li><p>handler： 这个参数代表如果我们线程池已经满了，外部仍添加线程对象，我们的处理方式。一般这种情况我们选择不接受新的线程对象。</p>
<pre><code>这个handler在处理的时候回抛RejectedExecutionException()并丢掉任务
RejectedExecutionHandler  handler = new ThreadPoolExecutor.AbortPolicy(); 
</code></pre></li>
</ol>
<p>注意：<br>　　我们参数5，如果设置成一个没有上限的缓存队列，因此缓存队列永远都不会满，因此 maximumPoolSize 的大小设置变得无所谓了。但是该方法对这几个数值有一个基本的要求，如果不满足就会抛出非法参数异常。</p>
<pre><code>@throws IllegalArgumentException if one of the following holds:&lt;br&gt;
         {@code corePoolSize &lt; 0}&lt;br&gt;
         {@code keepAliveTime &lt; 0}&lt;br&gt;
         {@code maximumPoolSize &lt;= 0}&lt;br&gt;
         {@code maximumPoolSize &lt; corePoolSize}
</code></pre><p>可见，即使maximumPoolSize大大小无所谓的时候我们保证他不小于核心线程数据量即corePoolSize的大小。了解各个参数的意义我们就可以创造出自己的一个ThreadPoolExcuter了：</p>
<pre><code>   int corePoolSize = Runtime.getRuntime().availableProcessors()*2 + 1;
int maximumPoolSize = corePoolSize;
long keepAliveTime = 2;
TimeUnit unit = TimeUnit.HOURS;
BlockingQueue&lt;Runnable&gt; workQueue = new LinkedBlockingQueue&lt;Runnable&gt;();
RejectedExecutionHandler  handler = new ThreadPoolExecutor.AbortPolicy();


    ThreadPoolExecutor executor = new ThreadPoolExecutor(
            corePoolSize, 
            maximumPoolSize, 
            keepAliveTime, 
            unit, 
            workQueue, 
            Executors.defaultThreadFactory(), 
            handler
            );
</code></pre><p>解释一下：</p>
<ol>
<li><code>int corePoolSize = Runtime.getRuntime().availableProcessors()*2 + 1;</code>    Runtime.getRuntime().availableProcessors()通过这个方法我们能拿到当前设备的可用的cpu数量，而大量研究表明，设备同时执行的线程数量跟可用cpu数量是有一定关系的，而这个关系就是上述这种算法。</li>
<li>由于我们设置了无界的缓存队列，因此我们maximunPoolSize的大小只要保证不小于corePoolsize就好。</li>
</ol>
<h3 id="线程池的用法："><a href="#线程池的用法：" class="headerlink" title="线程池的用法："></a>线程池的用法：</h3><p>  了解线程池的最难的定义方法，接下来就该说明线程池的使用了。线程池内部的维护原理虽然比较复杂，但是使用起来需要我们关心的还是很好少的。</p>
<ol>
<li><p>”执行“线程任务： 这里之所以加上引号，是因为即使你调用了execute方法，线程池也未必会执行这个任务。原因上边已经有所解释，即我们规定了最大同时运行线程数量：corePoolSize，如果当前线程数量小于规定值， 我们调用这个方法任务会立刻得到执行，如果当前的任务已经大于规定值，那么调用这个execute方法，任务将回到缓存队列去排队，等待执行。</p>
<p><code>executor.execute(runnable);</code></p>
</li>
<li><p>如果我们想要移除任务，比如说迅雷正下载任务的时候，我们点了取消下载，那么任务就从下载任务中取消了。线程池的这个原理也是一样的。</p>
<p><code>executor.remove(runnable);</code></p>
</li>
</ol>
<h3 id="自定义一个线程池管理类-ThreadPoolManager"><a href="#自定义一个线程池管理类-ThreadPoolManager" class="headerlink" title="自定义一个线程池管理类 ThreadPoolManager"></a>自定义一个线程池管理类 ThreadPoolManager</h3><p> 最近在做的项目，有一个需求就是，多个页面执行下载任务。如果我们经过简单的额封装，那么每个页面都要new出来这个“庞大的”线程池对象，岂不是要累死宝宝了。对于系统资源也是一种浪费。这里我们采用单例的ThreadPoolManager类，对外暴露执行任务和移除任务的方法，废话不多说代码如下：</p>
<pre><code>/**
  * 基于线程池进行封装的类
  *
  */
 public class ThreadPoolManager {
     private static ThreadPoolManager mInstance = new ThreadPoolManager();
     private ThreadPoolExecutor executor;

     int corePoolSize;//核心线程池数量，表示能够同时执行的任务的数量
     int maximumPoolSize;//最大线程池数量，超出缓冲队列的任务会放入最大线程池中等待，注意：maximumPoolSize是包含了corePoolSize的
     long keepAliveTime = 2;//存活时间，表示的是最大线程池中等待任务的存活时间
     TimeUnit unit = TimeUnit.HOURS;//时间单位
     //缓冲队列，会将超出corePoolSize的任务放入workQueue等待着，注意我们一般使用没有上限的缓冲队列
     BlockingQueue&lt;Runnable&gt; workQueue = new LinkedBlockingQueue&lt;Runnable&gt;();
     //如果任务数量超过maximumPoolSize，那么我是拒绝执行的
     RejectedExecutionHandler  handler = new ThreadPoolExecutor.AbortPolicy();

     public static ThreadPoolManager getInstance() {
         return mInstance;
     }
     private ThreadPoolManager() {
         //1.使用java封装好的线程池的类
 //        ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(3);

         //计算corePoolSize的算法:设备的可用处理器核心数*2 + 1，能够让cpu的效率得到最大发挥
         corePoolSize = Runtime.getRuntime().availableProcessors()*2 + 1;

         maximumPoolSize = corePoolSize;
         //2.使用可以自定义的线程池
         executor = new ThreadPoolExecutor(
                 corePoolSize, //3
                 maximumPoolSize, //5
                 keepAliveTime, 
                 unit, 
                 workQueue, 
                 Executors.defaultThreadFactory(), 
                 handler
                 );
     }

     /**
      * 往线程池中添加任务
      * @param runnable
      */
     public void execute(Runnable runnable){
         if(runnable!=null){
             executor.execute(runnable);
         }
     }
     /**
      * 从线程池中移除任务
      * @param runnable
      */
     public void remove(Runnable runnable){
         if(runnable!=null){
             executor.remove(runnable);
         }
     }
 }
</code></pre><h3 id="关于系统预定义的几个线程池接口实现类："><a href="#关于系统预定义的几个线程池接口实现类：" class="headerlink" title="关于系统预定义的几个线程池接口实现类："></a>关于系统预定义的几个线程池接口实现类：</h3><blockquote>
<p>声明一下内容来自网络某大神的博客，这里只是摘抄学习： <a href="http://my.oschina.net/u/1424386/blog/336087" target="_blank" rel="external">http://my.oschina.net/u/1424386/blog/336087</a></p>
</blockquote>
<p>在JDK帮助文档中，有如此一段话：“强烈建议程序员使用较为方便的Executors工厂方法Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）、Executors.newFixedThreadPool(int)（固定大小线程池）Executors.newSingleThreadExecutor()（单个后台线程）它们均为大多数使用场景预定义了设置。” </p>
<ol>
<li><p>Executors.newCachedThreadPool() 的系统源码为：</p>
<pre><code>public static ExecutorService newCachedThreadPool() {
return new ThreadPoolExecutor(
                              0,//这里为什么会填0？  
                              Integer.MAX_VALUE,
                              60L, 
                              TimeUnit.SECONDS,
                              new SynchronousQueue&lt;Runnable&gt;());
 }
</code></pre><p> SynchronousQueue，简单说：该队列中，每个插入操作必须等待另一个线程的对应移除操作。这里的核心线程数量设置为0，大概意思就是一起执行的线程数量不确定，所有的新加进来的线程都会被放在队列里面而SynchronousQueue这种队列又很特殊，下面是任玉刚在<android开发艺术探索中>对newCachedThreadPool的描述：</android开发艺术探索中></p>
<p> <img src="https://ooo.0o0.ooo/2016/08/21/57b9df462f6a8.png" alt=""></p>
</li>
<li><p>newFixedThreadPool: 该定义方法其实和上述我们自定义的ThreadPoolManger的方法相同，是无边界队列的线程池  </p>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre></li>
<li><p>newSingleThreadExecutor: 单线程</p>
<pre><code>public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;()));
    }
</code></pre></li>
</ol>
<p>我们可以看到上述三个对象，均返回了一个ExecutorService对象，因此可以看到我们之前了解的ThreadPool的各个参数是有意义的。</p>
<h2 id="关于选择哪个类型的队列：BlockingQueue"><a href="#关于选择哪个类型的队列：BlockingQueue" class="headerlink" title="关于选择哪个类型的队列：BlockingQueue"></a>关于选择哪个类型的队列：BlockingQueue</h2><ul>
<li>首先：所有 BlockingQueue 都可用于传输和保持提交的任务。可以使用此队列与池大小进行交互：<ol>
<li>如果运行的线程少于 corePoolSize，则 Executor始终首选添加新的线程，而不进行排队。（如果当前运行的线程小于corePoolSize，则任务根本不会存放，添加到queue中，而是直接抄家伙（thread）开始运行）</li>
<li>如果运行的线程等于或多于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。</li>
<li>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝</li>
</ol>
</li>
</ul>
<ul>
<li>排队有三种通用策略：<ol>
<li>直接提交。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</li>
<li>无界队列。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</li>
<li>有界队列。当使用有限的 maximumPoolSizes时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。  </li>
</ol>
</li>
</ul>
<ul>
<li><p>使用直接提交策略，也即SynchronousQueue。</p>
<ul>
<li>首先SynchronousQueue是无界的，也就是说他存数任务的能力是没有限制的，但是由于该Queue本身的特性，在某次添加元素后必须等待其他线程取走后才能继续添加。在这里不是核心线程便是新创建的线程，但是</li>
<li><p>我们试想一样下，下面的场景。我们使用一下参数构造ThreadPoolExecutor：</p>
<pre><code>new ThreadPoolExecutor(   
            2, 3, 30, TimeUnit.SECONDS,    
            new  SynchronousQueue&lt;Runnable&gt;(),    
             new RecorderThreadFactory(&quot;CookieRecorderPool&quot;),    
            new ThreadPoolExecutor.CallerRunsPolicy());  
</code></pre></li>
<li><p>当核心线程已经有2个正在运行.<br>此时继续来了一个任务（A），根据前面介绍的“如果运行的线程等于或多于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。”,所以A被添加到queue中。<br>又来了一个任务（B），且核心2个线程还没有忙完，OK，接下来首先尝试1中描述，但是由于使用的SynchronousQueue，所以一定无法加入进去。<br>此时便满足了上面提到的“如果无法将请求加入队列，则创建新的线程，除非创建此线程超出maximumPoolSize，在这种情况下，任务将被拒绝。”，所以必然会新建一个线程来运行这个任务。<br>暂时还可以，但是如果这三个任务都还没完成，连续来了两个任务，第一个添加入queue中，后一个呢？queue中无法插入，而线程数达到了maximumPoolSize，所以只好执行异常策略了。<br>所以在使用SynchronousQueue通常要求maximumPoolSize是无界的，这样就可以避免上述情况发生（如果希望限制就直接使用有界队列）。对于使用SynchronousQueue的作用jdk中写的很清楚：此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。<br>什么意思？如果你的任务A1，A2有内部关联，A1需要先运行，那么先提交A1，再提交A2，当使用SynchronousQueue我们可以保证，A1必定先被执行，在A1么有被执行前，A2不可能添加入queue中。</p>
</li>
</ul>
</li>
</ul>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>   线程池的使用 其实也没有想象中的那么复杂，毕竟这个java给我们定义好的类，内部的调度关系我们不需要深入了解就可以使用。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/android笔记/" rel="tag">#android笔记</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/13/UniversalImageLoader的初体验/" rel="next" title="UniversalImageLoader的初体验">
                <i class="fa fa-chevron-left"></i> UniversalImageLoader的初体验
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/08/21/Android中的动画-ValueAnimator值动画的使用/" rel="prev" title="Android中的动画---ValueAnimator值动画的使用">
                Android中的动画---ValueAnimator值动画的使用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="ImportEffort" />
          <p class="site-author-name" itemprop="name">ImportEffort</p>
          <p class="site-description motion-element" itemprop="description">说道做到，这就是我的忍道</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">1.0.1.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何创建一个ThreadPoolExecutor"><span class="nav-number">1.0.2.</span> <span class="nav-text">如何创建一个ThreadPoolExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池的用法："><span class="nav-number">1.0.3.</span> <span class="nav-text">线程池的用法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义一个线程池管理类-ThreadPoolManager"><span class="nav-number">1.0.4.</span> <span class="nav-text">自定义一个线程池管理类 ThreadPoolManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于系统预定义的几个线程池接口实现类："><span class="nav-number">1.0.5.</span> <span class="nav-text">关于系统预定义的几个线程池接口实现类：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于选择哪个类型的队列：BlockingQueue"><span class="nav-number">1.1.</span> <span class="nav-text">关于选择哪个类型的队列：BlockingQueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结："><span class="nav-number">1.2.</span> <span class="nav-text">总结：</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ImportEffort</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
